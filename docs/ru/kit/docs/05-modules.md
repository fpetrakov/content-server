---
title: Модули
---

В SvelteKit есть несколько модулей, которые доступны в приложении.


### $app/env

```js
import { amp, browser, dev, mode, prerendering } from '$app/env';
```

- `amp` равен либо `true`, либо `false` в зависимости от соответствующего значения в [конфигурации проекта](#konfiguracziya)
- `browser` будет равен `true` или `false` если приложение запущено соответственно в браузере или на сервере
- `dev` равен `true` в режиме разработки, `false` в рабочем режиме
- `mode` - это [Vite mode](https://vitejs.dev/guide/env-and-mode.html#modes), по-умолчанию `development` в режиме разработки или `production` во время сборки, если иное не настроено в `config.kit.vite.mode`.
- `prerendering` равен `true` во время [предварительной отрисовки](#parametry-straniczy-prerender), иначе `false`


### $app/navigation

```js
import {
 	disableScrollHandling,
 	goto,
 	invalidate,
 	prefetch,
 	prefetchRoutes,
 	beforeNavigate,
 	afterNavigate
 } from '$app/navigation';
```

- `afterNavigate(({ from, to }: { from: URL, to: URL }) => void)` - функция жизненного цикла, которая запускается при первоначальной отрисовке компонента, а также при каждой последующей навигации, пока компонент остается в отрисованным.
- `beforeNavigate(({ from, to, cancel }: { from: URL, to: URL | null, cancel: () => void }) => void)` — функция, которая запускается всякий раз, когда происходит навигация, будь то нажатие на ссылку, вызов `goto` или перемещение по истории браузера. Также она будет запущена и при переходе на внешние сайты. Если пользователь закрывает страницу, то в `to` будет значение `null`. Вызов `cancel` остановит выполнение перехода.
- `disableScrollHandling` запретит SvelteKit применить его обычное управление прокруткой страницы, если вызывается когда страница обновляется после перехода (например, в `onMount` или действии). Лучше избегать использования этой функции, чтобы не дезориентировать пользователей.
- `goto(href, { replaceState, noscroll, keepfocus, state })` возвращает `Promise`, который резолвится при навигации SvelteKit к указанному `href` (ошибка в навигации отклоняет промис). Второй аргумент является необязательным:
    - `replaceState` (boolean, по умолчанию `false`) Если `true`, заменит текущую запись `history`, а не создаст новую через `pushState`
    - `noscroll` (boolean, по умолчанию `false`) Если `true`, браузер сохранит свое положение прокрутки, а не прокрутит в верхнюю часть страницы после навигации
    - `keepfocus` (boolean, по умолчанию `false`) Если `true`, текущий сфокусированный элемент сохранит фокус после навигации. В противном случае фокус будет сброшен
    - `state` (объект, по умолчанию `{}`) Состояние новой/обновленной записи истории
- `invalidate(href)` перезапускает все функции `load`, которые нужны для текущей активной страницы для повторной загрузки необходимых ресурсов. Возвращает объект `Promise`, который разрешается, когда страница обновится новыми данными.
- `prefetch(href)` программно  выполняет упреждающую загрузку указанной страницы, что означает: а) обеспечение полной загрузки кода для страницы и б) вызов метода `load` страницы с соответствующими параметрами. Это поведение, аналогично случаю, когда пользователь касается на сенсорном экране или проводит курсором над элементом `<a>` с установленным атрибутом [sveltekit:prefetch](docs#atributy-ssylok-sveltekit-prefetch). Если следующий переход будет по пути `href`, то будет использовано значение, которое вернула функция `load`, что сделает перемещение мгновенным. Возвращает объект `Promise`, который разрешается, когда упреждающая загрузка будет завершена.
- `prefetchRoutes(routes)` — программно выполняет упреждающую загрузку кода для маршрутов, которые ещё не были загружены до этого. Обычно используется для ускорения переходов по нижестоящим маршрутам. Если не передавать аргументов, то будут предзагружены все маршруты, но можете указать маршруты по любому подходящему пути, например, `/about` (для `src/routes/about.svelte`) или `/blog/*` (для `src/routes/blog/[slug].svelte`). В отличие от `prefetch` не вызывает функцию `load` для каждой из загружаемых страниц.  Возвращает объект `Promise`, который разрешается, когда упреждающая загрузка всех маршрутов будет завершена.


### $app/paths

```js
import { base, assets } from '$app/paths';
```

- `base` — строка с путём, относительно корня (т.е. начинается с `/`), которая соответствует параметру `config.kit.paths.base` в [конфигурации проекта](#konfiguracziya)
- `assets` — путь от корня или абсолютный путь который соответствует параметру `config.kit.paths.assets` (после его разрешения относительно `base`)

> Если указано значение `config.kit.paths.assets`, во время выполнения [`svelte-kit dev`](#svelte-kit-cli-svelte-kit-dev) или [`svelte-kit preview`](#svelte-kit-cli-svelte-kit-preview) оно будет подменяться на `'/_svelte_kit_assets'`, так как статические ресурсы ещё не размещены по их окончательному URL-адресу.


### $app/stores

```js
import { getStores, navigating, page, session, updated } from '$app/stores';
```
Эти хранилища _зависят от контекста_, так как они добавляются в [контекст](https://ru.svelte.dev/tutorial/context-api) корневого компонента приложения. Это значит, что хранилища `session` и `page` будут уникальны для каждого запроса на сервер и не будут предоставлять одну и ту же информацию в нескольких запросах сразу. Поэтому можно безопасно хранить в `session` данные конкретного пользователя.

По этой причине доступ к хранилищу можно получить только во время инициализации компонента, как и в случае с любой функцией, которая использует метод `getContext` внутри.

- `getStores` — это удобная функция-оболочка вокруг `getContext`, которая возвращает `{ navigating, page, session, updated }`. Её необходимо вызывать на верхнем уровне или синхронно во время инициализации компонента или страницы.

Хранилища сами определяют нужный контекст, когда выполняется подписка на них, что означает, что вы можете импортировать и использовать их непосредственно в компонентах без лишней обвязки. Тем не менее, их его всё ещё нужно вызывать синхронно при инициализации компонента или страницы, когда  не используется префикс `$`. Вместо этого используйте `getStores`, чтобы безопасно асинхронно выполнить `.subscribe`.

- `navigating` - это [хранилище](https://ru.svelte.dev/tutorial/readable-stores). В процессе перехода при навигации его значением становится объект `{ from, to }`, где `from` и `to` являются экземплярами [`URL`](https://developer.mozilla.org/ru-RU/docs/Web/API/URL). Когда переход завершается, его значение возвращается к `null`.
- `page` содержит объект с текущими [`url`](https://developer.mozilla.org/ru-RU/docs/Web/API/URL), [`params`](#zagruzka-dannyh-poluchaemye-znacheniya-params), [`stuff`](#zagruzka-dannyh-vozvrashhaemye-znacheniya-stuff), [`status`](#loading-output-status) и [`error`](#loading-output-error).
- `session` – хранилище, начальное значение которого получается из функции [`getSession`](#huki-getsession). Значение в хранилище можно изменять, но эти изменения не будут сохранены на сервере – при необходимости это нужно имплементировать самостоятельно.
- `updated` - это [хранилище](https://ru.svelte.dev/tutorial/readable-stores), начальное значение которого равно `false`. Если в конфигурации задан [`version.pollInterval`](#konfiguracziya-version), SvelteKit будет периодически проверять новую версию приложения на сервере и как только обнаружит её, обновит значение хранилища до `true`. Вызов метода `updated.check()` принудительно проверит новую версию на сервере, независимо от настроек опроса.


### $lib

Это простой псевдоним для директории `src/lib`, или иной директории указанной в [`config.kit.files.lib`](#konfiguracziya). Он позволит обращаться к общим компонентам и утилитам без использования множества `../../../../` в путях импорта.


### $service-worker

Этот модуль доступен только в [сервис-воркерах](#servis-vorkery).

```js
import { build, files, timestamp } from '$service-worker';
```

- `build` – массив строк URL-путей до файлов сгенерированных Vite, используется для кеширования при помощи функции `cache.addAll(build)`
- `files` - это массив строк URL, представляющих файлы в вашем каталоге `static` или любой другой каталог, указанный [`config.kit.files.assets`](#konfiguracziya). Вы можете настроить, какие файлы включаются из каталога `static`, используя [`config.kit.serviceWorker.files`](#konfiguracziya)
- `timestamp` – результат вызова функции `Date.now()` во время сборки. Полезно для генерации уникальных имён для кешей внутри сервис-воркера, что позволит инвалидировать устаревшие кеши у клиентов при запуске новой версии приложения.


### @sveltejs/kit/hooks

Этот модуль содержит хелпер-функцию `sequence` для создания последовательности из нескольких вызовов в `handle`.

```js
import { sequence } from '@sveltejs/kit/hooks';

async function first({ event, resolve }) {
  console.log('первая пред-обработка');
 	const result = await resolve(event);
 	console.log('первая пост-обработка');
 	return result;
}
async function second({ event, resolve }) {
  console.log('вторая пред-обработка');
 	const result = await resolve(event);
 	console.log('вторая пост-обработка');
 	return result;
}

export const handle = sequence(first, second);
```

Пример выше распечатает:
>первая пред-обработка
>вторая пред-обработка
>вторая пост-обработка
>первая пост-обработка